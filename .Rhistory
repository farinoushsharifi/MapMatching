"Longitude"=latlong$LongList, "Time"=latlong$timeseq,
"Distance.km"=distvec, "CumulativeDistance.km"=cumsum(distvec),
"Speed.km/h"=distvec/timediff,
"AverageTotalSpeed"=cumsum(distvec)/cumsum(timediff))
View(disttbl)
latlong <- data.frame(LatList,LongList,timeseq)
latlong <- latlong[order(latlong$timeseq),]
distvec <- rep(0,times=nrow(latlong))
latlong <- latlong %>% mutate(nextLat = lag(LatList),nextLng = lag(LongList))
latlong <- data.frame(LatList,LongList,timeseq)
latlong <- latlong[order(latlong$timeseq),]
distvec <- rep(0,times=nrow(latlong))
latlong <- latlong %>% mutate(lastLat = lag(LatList),lasttLng = lag(LongList))
geosphere::distHaversine(cbind(latlong$LongList,latlong$LatList),
cbind(latlong$lasttLng,latlong$lastLat))
distance <- geosphere::distHaversine(cbind(latlong$LongList,latlong$LatList),
cbind(latlong$lasttLng,latlong$lastLat))
distance[1] <- 0
View(disttbl)
latlong <- data.frame(LatList,LongList,timeseq)
latlong <- latlong[order(latlong$timeseq),]
latlong <- latlong %>% mutate(lastLat = lag(LatList),lasttLng = lag(LongList))
distvec <- geosphere::distHaversine(cbind(latlong$LongList,latlong$LatList),
cbind(latlong$lasttLng,latlong$lastLat))/1000
distvec[1] <- 0
timediff <- c(1/3600,diff(as.numeric(latlong$timeseq))/3600)
disttbl <- data.frame("PointNumber"=seq(1,nrow(latlong),1), "Latitude"=latlong$LatList,
"Longitude"=latlong$LongList, "Time"=latlong$timeseq,
"Distance.km"=distvec, "CumulativeDistance.km"=cumsum(distvec),
"Speed.km/h"=distvec/timediff,
"AverageTotalSpeed"=cumsum(distvec)/cumsum(timediff))
disttbl <- data.frame("PointNumber"=seq(1,nrow(latlong),1), "Latitude"=latlong$LatList,
"Longitude"=latlong$LongList, "Time"=latlong$timeseq,
"Distance.km"=distvec, "CumulativeDistance.km"=cumsum(distvec),
"Speed.kmph"=distvec/timediff,
"AverageTotalSpeed.kmph"=cumsum(distvec)/cumsum(timediff))
compute_distance <- function(LatList, LongList,timeseq){
latlong <- data.frame(LatList,LongList,timeseq)
latlong <- latlong[order(latlong$timeseq),]
latlong <- latlong %>% mutate(lastLat = lag(LatList),lasttLng = lag(LongList))
distvec <- geosphere::distHaversine(cbind(latlong$LongList,latlong$LatList),
cbind(latlong$lasttLng,latlong$lastLat))/1000
distvec[1] <- 0
timediff <- c(1/3600,diff(as.numeric(latlong$timeseq))/3600)
disttbl <- data.frame("PointNumber"=seq(1,nrow(latlong),1), "Latitude"=latlong$LatList,
"Longitude"=latlong$LongList, "Time"=latlong$timeseq,
"Distance.km"=distvec, "CumulativeDistance.km"=cumsum(distvec),
"Speed.kmph"=distvec/timediff,
"AverageTotalSpeed.kmph"=cumsum(distvec)/cumsum(timediff))
return(disttbl)
}
disttbl <- compute_distance(LatList,LongList,timeseq)
View(disttbl)
View(boxtable)
View(highway)
highway2 <- highway %>%
mutate(equal = lead(V1))
highway2 <- data.frame(highway) %>%
mutate(equal = lead(V1))
data.frame(highway)
as.data.frame(highway)
highway2 <- as.data.frame(highway) %>%
mutate(equal = lead(V1))
View(highway2)
as.data.frame(highway) %>% mutate(equal = lag(V1)-V1)
highway2 <- as.data.frame(highway) %>% mutate(equal = lag(V1))
highway2 <- as.data.frame(highway) %>% mutate(k1lag = lag(V1))
highway2[highway2$V1!=highway2$k1lag,]
highway2 <- as.data.frame(highway)%>%mutate(k1lag = lag(V1))%>% mutate(k1lead = lead(V1))
highway2[highway2$V1!=highway2$k1lag,][highway2$k1lag==highway2$k1lead,]
highway2[highway2$V1!=highway2$k1lag,]->l
View(l)
View(highway)
highway2 <- as.data.frame(highway)%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
highway2[highway2$V1!=highway2$k1lag,]->l
View(l)
l[highway2$k1lag!=highway2$k1lead,]
l[highway2$k1lag!=highway2$k1lead,]->o
View(o)
l[l$k1lag!=l$k1lead,]->o
l[l$k1lag==l$k1lead,]->o
highway2[o,]
highway2[o]
highway2$V1[l$k1lag==l$k1lead,] <- highway2$k1lag
highway2$V1[l$k1lag==l$k1lead,]
highway2$V1[l$k1lag==l$k1lead]
highway2[l$k1lag==l$k1lead,]
highway2$V1[l$k1lag==l$k1lead]->h
highway2$V1[l$k1lag==l$k1lead,]->h
highway2$V1[which(l$k1lag==l$k1lead),]->h
highway2$V1[which(l$k1lag==l$k1lead)]->h
h
rownames(highway2)
View(boxtable)
data.frame("PointNumber"=rownames(highway))
data.frame("PointNumber"=seq(1,length(LatList)),highway)
highway <- data.frame("PointNumber"=seq(1,length(LatList)),highway)
highway <- as.data.frame(highway)%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
highway <- highway%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
View(highway)
api <- osmar::osmsource_api(osmlink)
highway <-  matrix(0,nrow=length(LatList),ncol=k)
for (i in 1:ncol(boxlist)) {
mapbox <- osmar::corner_bbox(boxlist[1,i],boxlist[2,i],boxlist[3,i],boxlist[4,i])
location <- osmar::get_osm(mapbox, source = api)
hwaysdata <- subset(location, way_ids = osmar::find(location, osmar::way(osmar::tags(k == "highway"))))
hways <- osmar::find(hwaysdata, osmar::way(osmar::tags(k == "name")))
hways <- osmar::find_down(location, osmar::way(hways))
hwaysdata <- subset(location, ids = hways)
hwaynodetbl <- hwaysdata$nodes$attrs
nnmat <- RANN::nn2(cbind(hwaynodetbl$lon, hwaynodetbl$lat),
cbind(LongList[boxcuts==i], LatList[boxcuts==i]),k)
nnmat <- matrix(hwaynodetbl[matrix(nnmat$nn.idx,ncol = k),1],ncol = k)
for(j in 1:nrow(nnmat)){
print(j)
hwaylist <- unique(osmar::find_up(hwaysdata, node(nnmat[j,]))$way_ids)
count <- length(hwaylist)
if (count>k) {
count <- k
}
highway[boxcuts==i,][j,1:k] <- hwaylist[1:k]
}
}
highway2 <- as.data.frame(highway)
highway2 <- highway2%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
highway2 <- cbind("PointNumber"=seq(1,length(LatList)),highway2)
highway2 <- highway2%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
View(highway2)
highway <- cbind("PointNumber"=seq(1,length(LatList)),as.data.frame(highway))
highway <- highway%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
View(highway)
highway[highway$V1!=highway$k1lag,]
highway[highway$V1!=highway$k1lag,]$PointNumber
highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]
highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
PointID <- highway$PointNumber[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
highway[highway$PointNumber=PointID]
highway[highway$PointNumber==PointID]
highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]
highway[PointID,]
highway$V1[PointID,]
highway[PointID,"V1"]
highway[PointID,"V1"] <- highway[PointID,"k1lag"]
highway[PointID,"k1lag"]
highway$V1[PointID,]
highway$V1[PointID]
highway$k1lag[PointID]
highway[PointID]
highway[PointID,]
highway$V1[PointID] <- highway$k1lag[PointID]
PointID <- PointID[!is.na(PointID)]
highway$V1[PointID] <- highway$k1lag[PointID]
highway[PointID,]
View(highway)
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
list(highway$V1)
match_highway <- function (LatList, LongList, k,
boxcuts = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxtable$boxcuts,
boxlist = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxlist,
resolution = 10, offLong = 0.001, offLat = 0.001,
osmlink = "https://api.openstreetmap.org/api/0.6/") {
if (length(LatList)!=length(LongList)) {
stop("Latitude and longitude lists do not have the same length")
}
if (length(LatList)!=length(boxcuts)) {
stop("Latitude and bounding box cut lists do not have the same length")
}
if ((k!= round(k))|(k<0)|(k==0)){
stop("k is not acceptable, please enter a positive integer")
}
api <- osmar::osmsource_api(osmlink)
highway <-  matrix(0,nrow=length(LatList),ncol=k)
for (i in 1:ncol(boxlist)) {
mapbox <- osmar::corner_bbox(boxlist[1,i],boxlist[2,i],boxlist[3,i],boxlist[4,i])
location <- osmar::get_osm(mapbox, source = api)
hwaysdata <- subset(location, way_ids = osmar::find(location, osmar::way(osmar::tags(k == "highway"))))
hways <- osmar::find(hwaysdata, osmar::way(osmar::tags(k == "name")))
hways <- osmar::find_down(location, osmar::way(hways))
hwaysdata <- subset(location, ids = hways)
hwaynodetbl <- hwaysdata$nodes$attrs
nnmat <- RANN::nn2(cbind(hwaynodetbl$lon, hwaynodetbl$lat),
cbind(LongList[boxcuts==i], LatList[boxcuts==i]),k)
nnmat <- matrix(hwaynodetbl[matrix(nnmat$nn.idx,ncol = k),1],ncol = k)
for(j in 1:nrow(nnmat)){
print(j)
hwaylist <- unique(osmar::find_up(hwaysdata, node(nnmat[j,]))$way_ids)
count <- length(hwaylist)
if (count>k) {
count <- k
}
highway[boxcuts==i,][j,1:k] <- hwaylist[1:k]
}
}
highway <- cbind("PointNumber"=seq(1,length(LatList)),as.data.frame(highway))
highway <- highway%>%mutate(k1lag = lag(V1), k1lead = lead(V1))
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
PointID <- PointID[!is.na(PointID)]
highway$V1[PointID] <- highway$k1lag[PointID]
highway <- list(highway$V1)
return("HighwayLinkID"=highway)
}
match_highway <- function (LatList, LongList, 7)
match_highway <- function (LatList, LongList, k=7)
match_highway(LatList, LongList, 7)
get_boxes <- function(LatList, LongList, timeseq, resolution=100, offLong=0.001,offLat=0.001){
if (length(LatList)!=length(LongList)) {
stop("Latitude and longitude lists do not have the same length")
}
if (length(LatList)!=length(timeseq)) {
stop("Latitude and time sequence lists do not have the same length")
}
if (any(class(timeseq)!=c("POSIXct","POSIXt"))){
stop("Time Sequense in not in POSIXct or POSIXt format. You can change it using the as.POSIXct or as.POSIXlt functions")
}
if ((!(offLong>0))|(!(offLat>0))) {
stop("offLong and offLat should be positive decimal degrees")
}
disttbl <- compute_distance(LatList,LongList,timeseq)
LatList <- disttbl$Latitude
LongList <- disttbl$Longitude
timeseq <- disttbl$Time
if (any(resolution < disttbl$Distance.km)) {
warning("Resolution is at least smaller than one recorded time interval")
}
totaldist <- disttbl$CumulativeDistance.km[nrow(disttbl)]
if (totaldist < resolution) {
boxlist <- osmar::corner_bbox(min(LongList)-offLong,
min(LatList)-offLat,
max(LongList)+offLong,
max(LatList)+offLat)
boxlist <- cbind(boxlist)
colnames(boxlist) <- "Group 1"
disttbl$boxcuts <- 1
warning("Resolution is too large for this area, only one box has been generated")
} else {
distintervals <- floor(totaldist/resolution)+1
disttbl$boxcuts <- factor(cut(disttbl$CumulativeDistance.km,distintervals, labels = seq(1,distintervals,1)))
disttbl$boxcuts <- factor(disttbl$boxcuts,labels = seq(1,nlevels(disttbl$boxcuts),1))
Latmax <- aggregate(disttbl$Latitude, list(disttbl$boxcuts), max)$x
Latmin <- aggregate(disttbl$Latitude, list(disttbl$boxcuts), min)$x
Longmax <- aggregate(disttbl$Longitude, list(disttbl$boxcuts), max)$x
Longmin <- aggregate(disttbl$Longitude, list(disttbl$boxcuts), min)$x
Timemax <- aggregate(disttbl$Time, list(disttbl$boxcuts), max)$x
Timemin <- aggregate(disttbl$Time, list(disttbl$boxcuts), min)$x
Distsum <- aggregate(disttbl$Distance.km, list(disttbl$boxcuts), sum)$x
aggdatatbl <- data.frame("Max Latitude" = Latmax,"Min Latitude" = Latmin,
"Max Longitude" = Longmax,"Min Longitude" = Longmin,
"Start Time" = Timemin, "End Time" = Timemax, "Total Distance.km" =Distsum )
boxlist <- c()
for(i in 1:nrow(aggdatatbl)) {
newbox <- osmar::corner_bbox(aggdatatbl$Min.Longitude[i]-offLong,
aggdatatbl$Min.Latitude[i]-offLat,
aggdatatbl$Max.Longitude[i]+offLong,
aggdatatbl$Max.Latitude[i]+offLat)
boxlist <- cbind(boxlist,newbox)
}
colnames(boxlist) <- paste("Group",seq(1,nrow(aggdatatbl),1),sep = "")
}
return(list("boxlist"=boxlist, "boxtable"=disttbl))
}
compute_distance <- function(LatList, LongList,timeseq){
latlong <- data.frame(LatList,LongList,timeseq)
latlong <- latlong[order(latlong$timeseq),]
latlong <- latlong %>% mutate(lastLat = lag(LatList),lasttLng = lag(LongList))
distvec <- geosphere::distHaversine(cbind(latlong$LongList,latlong$LatList),
cbind(latlong$lasttLng,latlong$lastLat))/1000
distvec[1] <- 0
timediff <- c(1/3600,diff(as.numeric(latlong$timeseq))/3600)
disttbl <- data.frame("PointNumber"=seq(1,nrow(latlong),1), "Latitude"=latlong$LatList,
"Longitude"=latlong$LongList, "Time"=latlong$timeseq,
"Distance.km"=distvec, "CumulativeDistance.km"=cumsum(distvec),
"Speed.kmph"=distvec/timediff,
"AverageTotalSpeed.kmph"=cumsum(distvec)/cumsum(timediff))
return(disttbl)
}
get_boxes(LatList, LongList, timeseq, resolution=1000,offLong,offLat)
#generates only one box and gives warning for the small resolution
get_boxes(LatList, LongList, timeseq, resolution=0.001,offLong,offLat)
#generates two bounding boxes
get_boxes(LatList, LongList, timeseq, resolution=0.1,offLong,offLat)
get_boxes(LatList, LongList, timeseq, resolution=1000,offLong,offLat)
get_boxes(LatList, LongList, timeseq, resolution=0.001,offLong,offLat)
get_boxes(LatList, LongList, timeseq, resolution=0.1,offLong,offLat)
library(TransGPS)
detach("package:MapMatching", unload = TRUE)
library(TransGPS)
boxtable
boxlist
#' Coordinates Map Matching
#'
#' Snap a set of GPS coordinates to the \href{https://www.openstreetmap.org}{OpenStreetMap (OSM)} data highways. This function facilitates the common process in two ways:
#' \itemize{
#'   \item Dividing the whole region into bounding boxes, which allows using the OSM data through API sourcing instead of setting up an OSM data server
#'   \item implement the fast K-Nearest Neighbor method to find the closest K links to each GPS coordinate
#' }
#'
#' @param LatList list of latitudes collected from a GPS recording device
#' @param LongList list of longitudes collected from a GPS recording device
#' @param timeseq list of time series for GPS recording device in format \code{"\%Y-\%m-\%d \%H:\%M:\%S"}
#' @param k maximum number of close highways to consider for the KNN analysis of each GPS coordinate
#' @param boxcuts a list of bounding box group number for each latitude and longitude (should be the same length as \code{LatList} and \code{LatList}; it can be generated from the \code{\link{get_boxes}} function by \code{~boxtable$boxcuts})
#' @param boxlist a list of bounding boxes coordinations; each bounding box coordinates is in the form of \code{("left","bottom","right","top")} (it can be generated from the \code{\link{get_boxes}} function by \code{~boxlist})
#' @param resolution an approximation of GPS recorded distance within each desired bounding box in kilometers (to be used for \code{\link{get_boxes}})
#' @param offLong a positive bounding box longitudal margin in decimal degrees (to be used for \code{\link{get_boxes}})
#' @param offLat a positive bounding box latitudal margin in decimal degrees (to be used for \code{\link{get_boxes}})
#' @param osmlink the API link for the \href{https://www.openstreetmap.org}{OpenStreetMap} data
#'
#' @return \code{\link{match_highway}} return a list of highway link IDs based on \href{https://www.openstreetmap.org}{OpenStreetMap} specification for the given GPS coordinates
#' @export
#'
#' @examples
match_highway <- function (LatList, LongList, timeseq, k,
boxcuts = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxtable$boxcuts,
boxlist = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxlist,
resolution = 10, offLong = 0.001, offLat = 0.001,
osmlink = "https://api.openstreetmap.org/api/0.6/") {
if (length(LatList)!=length(LongList)) {
stop("Latitude and longitude lists do not have the same length")
}
if (length(LatList)!=length(boxcuts)) {
stop("Latitude and bounding box cut lists do not have the same length")
}
if ((k!= round(k))|(k<0)|(k==0)){
stop("k is not acceptable, please enter a positive integer")
}
api <- osmar::osmsource_api(osmlink)
highway <-  matrix(0,nrow=length(LatList),ncol=k)
for (i in 1:ncol(boxlist)) {
mapbox <- osmar::corner_bbox(boxlist[1,i],boxlist[2,i],boxlist[3,i],boxlist[4,i])
location <- osmar::get_osm(mapbox, source = api)
hwaysdata <- subset(location, way_ids = osmar::find(location, osmar::way(osmar::tags(k == "highway"))))
hways <- osmar::find(hwaysdata, osmar::way(osmar::tags(k == "name")))
hways <- osmar::find_down(location, osmar::way(hways))
hwaysdata <- subset(location, ids = hways)
hwaynodetbl <- hwaysdata$nodes$attrs
nnmat <- RANN::nn2(cbind(hwaynodetbl$lon, hwaynodetbl$lat),
cbind(LongList[boxcuts==i], LatList[boxcuts==i]),k)
nnmat <- matrix(hwaynodetbl[matrix(nnmat$nn.idx,ncol = k),1],ncol = k)
for(j in 1:nrow(nnmat)){
hwaylist <- unique(osmar::find_up(hwaysdata, node(nnmat[j,]))$way_ids)
count <- length(hwaylist)
if (count>k) {
count <- k
}
highway[boxcuts==i,][j,1:k] <- hwaylist[1:k]
}
}
highway <- cbind("PointNumber"=seq(1,length(LatList)),as.data.frame(highway))
highway <- highway%>% dplyr::mutate(k1lag = lag(V1), k1lead = lead(V1))
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
PointID <- PointID[!is.na(PointID)]
highway$V1[PointID] <- highway$k1lag[PointID]
highway <- list(highway$V1)
return("HighwayLinkID"=highway)
}
#' Coordinates Map Matching
#'
#' Snap a set of GPS coordinates to the \href{https://www.openstreetmap.org}{OpenStreetMap (OSM)} data highways. This function facilitates the common process in two ways:
#' \itemize{
#'   \item Dividing the whole region into bounding boxes, which allows using the OSM data through API sourcing instead of setting up an OSM data server
#'   \item implement the fast K-Nearest Neighbor method to find the closest K links to each GPS coordinate
#' }
#'
#' @param LatList list of latitudes collected from a GPS recording device
#' @param LongList list of longitudes collected from a GPS recording device
#' @param timeseq list of time series for GPS recording device in format \code{"\%Y-\%m-\%d \%H:\%M:\%S"}
#' @param k maximum number of close highways to consider for the KNN analysis of each GPS coordinate
#' @param boxcuts a list of bounding box group number for each latitude and longitude (should be the same length as \code{LatList} and \code{LatList}; it can be generated from the \code{\link{get_boxes}} function by \code{~boxtable$boxcuts})
#' @param boxlist a list of bounding boxes coordinations; each bounding box coordinates is in the form of \code{("left","bottom","right","top")} (it can be generated from the \code{\link{get_boxes}} function by \code{~boxlist})
#' @param resolution an approximation of GPS recorded distance within each desired bounding box in kilometers (to be used for \code{\link{get_boxes}})
#' @param offLong a positive bounding box longitudal margin in decimal degrees (to be used for \code{\link{get_boxes}})
#' @param offLat a positive bounding box latitudal margin in decimal degrees (to be used for \code{\link{get_boxes}})
#' @param osmlink the API link for the \href{https://www.openstreetmap.org}{OpenStreetMap} data
#'
#' @return \code{\link{match_highway}} return a list of highway link IDs based on \href{https://www.openstreetmap.org}{OpenStreetMap} specification for the given GPS coordinates
#' @export
#'
#' @examples
#'
#' LatList <- c(31.67514,31.675195,31.67525,
#' 31.675304,31.675356,31.675408,31.675467,
#' 31.675517,31.675569,31.675623)
#'
#' LongList <- c(-106.326522,-106.326367,
#' -106.326211,-106.326058,-106.325901,
#' -106.325739,-106.325572,-106.32541,
#' -106.325247,-106.325092)
#'
#' timeseq <- c("2019-04-29 15:20:51",
#' "2019-04-29 15:21:03","2019-04-29 15:21:06",
#' "2019-04-29 15:21:15","2019-04-29 15:21:17",
#' "2019-04-29 15:21:32","2019-04-29 15:21:34",
#' "2019-04-29 15:21:51","2019-04-29 15:22:09",
#' "2019-04-29 15:22:36")
#'
#' timeseq <- as.POSIXct(timeseq)
#'
#' k=5
#'
#' resolution <- 0.1
#' offLong=0.001
#' offLat=0.002
#'
#' match_highway(LatList, LongList, timeseq, k,
#' resolution = resolution,offLong = offLong, offLat = offLat)
#'
#'
match_highway <- function (LatList, LongList, timeseq, k,
boxcuts = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxtable$boxcuts,
boxlist = get_boxes(LatList,LongList,timeseq,resolution,offLong,offLat)$boxlist,
resolution = 10, offLong = 0.001, offLat = 0.001,
osmlink = "https://api.openstreetmap.org/api/0.6/") {
print(boxcuts)
if (length(LatList)!=length(LongList)) {
stop("Latitude and longitude lists do not have the same length")
}
if (length(LatList)!=length(boxcuts)) {
stop("Latitude and bounding box cut lists do not have the same length")
}
if ((k!= round(k))|(k<0)|(k==0)){
stop("k is not acceptable, please enter a positive integer")
}
api <- osmar::osmsource_api(osmlink)
highway <-  matrix(0,nrow=length(LatList),ncol=k)
for (i in 1:ncol(boxlist)) {
mapbox <- osmar::corner_bbox(boxlist[1,i],boxlist[2,i],boxlist[3,i],boxlist[4,i])
location <- osmar::get_osm(mapbox, source = api)
hwaysdata <- subset(location, way_ids = osmar::find(location, osmar::way(osmar::tags(k == "highway"))))
hways <- osmar::find(hwaysdata, osmar::way(osmar::tags(k == "name")))
hways <- osmar::find_down(location, osmar::way(hways))
hwaysdata <- subset(location, ids = hways)
hwaynodetbl <- hwaysdata$nodes$attrs
nnmat <- RANN::nn2(cbind(hwaynodetbl$lon, hwaynodetbl$lat),
cbind(LongList[boxcuts==i], LatList[boxcuts==i]),k)
nnmat <- matrix(hwaynodetbl[matrix(nnmat$nn.idx,ncol = k),1],ncol = k)
for(j in 1:nrow(nnmat)){
hwaylist <- unique(osmar::find_up(hwaysdata, node(nnmat[j,]))$way_ids)
count <- length(hwaylist)
if (count>k) {
count <- k
}
highway[boxcuts==i,][j,1:k] <- hwaylist[1:k]
}
}
highway <- cbind("PointNumber"=seq(1,length(LatList)),as.data.frame(highway))
highway <- highway%>% dplyr::mutate(k1lag = lag(V1), k1lead = lead(V1))
PointID <- highway[(highway$V1!=highway$k1lag)&(highway$k1lag==highway$k1lead),]$PointNumber
PointID <- PointID[!is.na(PointID)]
highway$V1[PointID] <- highway$k1lag[PointID]
highway <- list(highway$V1)
return("HighwayLinkID"=highway)
}
LatList <- c(31.67514,31.675195,31.67525,
31.675304,31.675356,31.675408,31.675467,
31.675517,31.675569,31.675623)
LongList <- c(-106.326522,-106.326367,
-106.326211,-106.326058,-106.325901,
-106.325739,-106.325572,-106.32541,
-106.325247,-106.325092)
timeseq <- c("2019-04-29 15:20:51",
"2019-04-29 15:21:03","2019-04-29 15:21:06",
"2019-04-29 15:21:15","2019-04-29 15:21:17",
"2019-04-29 15:21:32","2019-04-29 15:21:34",
"2019-04-29 15:21:51","2019-04-29 15:22:09",
"2019-04-29 15:22:36")
timeseq <- as.POSIXct(timeseq)
k=5
resolution <- 0.1
offLong=0.001
offLat=0.002
match_highway(LatList, LongList, timeseq, k,
resolution = resolution,offLong = offLong, offLat = offLat)
boxcuts <- c(1,1,1,2,2,3,3,3,4,4)
boxlist
boxlist[,1]
boxlist[,3]
boxlist[,34]
boxlist[,4]
boxlist[,7]
boxcuts <- c(1,1,1,2,2,3,3,3,4,4)
boxlist <- cbind(c(-106.32752,31.67414,-106.28746,31.69790),
c(-106.26872,31.73050,-106.26627,31.77233),
c(-106.26915,31.77057,-106.26671,31.81236),
c(-106.36679,31.81582,-106.34707,31.84163))
match_highway(LatList, LongList, timeseq,
k, boxcuts=boxcuts, boxlist=boxlist)
devtools::install_github("farinoushsharifi/MapMatching")
devtools::install_github("farinoushsharifi/TransGPS")
devtools::install_github("farinoushsharifi/MapMatching")
devtools::install_github("farinoushsharifi/MapMatching")
devtools::install_github("farinoushsharifi/TransGPS")
library(osmar)
detach("package:osmar", unload = TRUE)
detach("package:TransGPS", unload = TRUE)
install.packages("devtools")
install.packages("devtools")
devtools::use_package("osmar")
install.packages("osmar")
devtools::use_package("osmar")
remove.packages("osmar", lib="~/R/win-library/3.3")
remove.packages("RCurl", lib="~/R/win-library/3.3")
remove.packages("Curl", lib="~/R/win-library/3.3")
remove.packages("curl", lib="~/R/win-library/3.3")
install.packages(osmar)
install.packages("osmar")
library(osmar)
install.packages(RCurl)
install.packages("RCurl")
library(osmar)
library(TransGPS)
